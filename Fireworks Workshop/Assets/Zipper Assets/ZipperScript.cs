using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using FireworksMania.Core.Behaviors.Fireworks;
using FireworksMania.Core.Behaviors.Fireworks.Parts;


[ExecuteAlways]
public class ZipperScript : MonoBehaviour
{
#if UNITY_EDITOR
    [Header("Parent Particle System")]
    [Tooltip("This is the Particle System that all the Zipper Particle Systems Will be created under\n\nThe Position and rotation of this particle system will effect the position and rotation of the zipper\n\nYou can add a start Delay to this particle system to delay when the zipper effect will start")]
    public ParticleSystem ParentObject;

    [Header("Particle Effect")]
    [Tooltip("The Effect that will be used in the zipper")]
    public ParticleSystem LaunchEffect;

    [Header("Number of Effects")]
    [Tooltip("This is the number of launch effects you want in your zipper")]
    public int Number = 0;

    [Header("Angle Between Effects")]
    [Tooltip("This is the angle between each launch effect in the fan")]
    public float LaunchAngles = 10f;

    [Header("Position Between Each Effect")]
    [Tooltip("This is the Position Between Each effect on your zipper")]
    public float PositionSpacing = 0f;


    [ReadOnly]

    [Space(30)]
    [Header("=========== Zipper Player Settings ===========")]
    [Space(30)]
    public string EffectPlayer = "ZIPPER PLAYER";


    [ReadOnly]

    [Header("Read Only - Total Number of Zipper Bursts")]
    [Tooltip("The total numbe of time an effect will be played in the zipper")]
    public string TotalEffects = "0 Effects";


    [ReadOnly]

    [Header("Read Only - Total Time of Zipper Effect")]
    [Tooltip("The estimated total time of the zipper effect for 1 play through")]
    public string TotalTimeR = "0 Seconds";


    [ReadOnly]

    [Header("Read Only - Total Duration of Zipper")]
    [Tooltip("The estimated total duration of the zipper")]
    public string TotalDuration = "0 Seconds";


    [Header("Start from left to right")]
    [Tooltip("Enable to start the cake playing from left to right, disable to start from the right and go left")]
    public bool PlayDirection = true;

    [Header("Start Delay")]
    [Tooltip("This is the Start Delay on your parent particle system")]
    public float StartDelay = 0f;

    [Header("Time Delay Between Launch Effects")]
    [Tooltip("This is the time between each launch effect in the zipper")]
    public float TimeDelay = 1f;

    [Header("Time Multipier")]
    [Tooltip("The Time Delay is multiplied by this value after one Cycle is completed (one back and forth zipper)\n\nThis does not continue between repeats of a zipper, so the value will reset every time it repeats")]
    [Range(0, 2)]
    public float Multiplier = 1.0f;

    [Header("Number of Cycles")]
    [Tooltip("This is the number of times your fan effect will play\nIf set to one the zipper will fire all its launch effects once\nIf set to two the zipper will fire all its launch effects and then play them again in the reverse direction")]
    public int Cycles = 2;

    [Header("Time Delay Between Cycles")]
    [Tooltip("This is the time between each launch effect in the zipper")]
    public float CycleDelay = 0.1f;

    [Header("Number of times to repeat the zipper")]
    [Tooltip("Repeates the enitre zipper with start delay this many times")]
    public int Repeat = 1;

    [Header("Max particles of each Zipper effect")]
    [Tooltip("Set the max particles that can spawn from each zipper effect")]
    public int MaxParticles = 100000;

    [Header("Zipper Particle System List")]
    [Tooltip("These are the particle systems used by the zipper script\nThese objects can be generated by the script or assigned by you manually\nIf you edit a particle system created by the script you may need to re add it to the list")]
    public List<ParticleSystem> Fan;

    [Header("Delays between each cycle")]
    [Tooltip("This allows you to set a specific time in between each individual cycle")]
    [HideInInspector]
    public bool EnableCustomDelays = false;
    [Tooltip("This is the value of time between each cycle")]
    [HideInInspector]
    [SerializeField]
    public List<float> CycleDelays = new List<float>();

    [Header("Start Direction of Each Cycle")]
    [Tooltip("This allows you to set a specific time in between each individual cycle")]
    [HideInInspector]
    public bool CustomDirections = false;

    [ReadOnly]

    [HideInInspector]
    [Tooltip("Boxes with a check indicate that cycle starts from left to right, non check is from right to left")]
    public string Key = "Check mark = Left -> Right";
    [Tooltip("This is the value of time between each cycle")]
    [HideInInspector]
    [SerializeField]
    public List<bool> StartDirections = new List<bool>();


    [Header("")]
    [Tooltip("FOR ADVANCED USEAGE\n\nAllows you to manually set the Poperties of the individual cycles")]
    public bool AdvancedSettings = false;


    [HideInInspector]
    public bool DoesFanExist;

    private int fanSize;
    private float MaxSystems;
    private float CurrTime = 0;
    private float TotalTime;
    private float RealTimeDelay;

    private ParticleSystem.Burst burst = new ParticleSystem.Burst();

    [HideInInspector]
    public bool OverrideLaunchEffectBurst = true;



    #region Editor Code
    private void updatetime()
    {
        TotalTimeR = (TotalTime).ToString("f2") + " Seconds";
        TotalDuration = ((TotalTime + StartDelay) * Repeat).ToString("f2") + " Seconds";
    }


    private void OnValidate()
    {
        Cycles = (int)Mathf.Clamp(Cycles, 0, 8);
        Repeat = (int)Mathf.Clamp(Repeat, 1, 1000);
        if (Number < 0) Number = 0;
        if (TimeDelay != 0) TimeDelay = Mathf.Clamp(TimeDelay, 0f, 100);
        StartDelay = Mathf.Clamp(StartDelay, 0f, 1000f);
        CycleDelay = Mathf.Clamp(CycleDelay, 0f, 1000f);

        if (ParentObject == null && IsthisPS(gameObject))
        {
            ParentObject = this.GetComponent<ParticleSystem>();
        }

        if (ParentObject == LaunchEffect)
        {
            Debug.LogError("The Launch Effect Cannot Be the same as the Parent Object!!!");
            ParentObject = null;
            return;
        }


        try
        {
            if (!LaunchEffect)
            {
                throw new System.ArgumentNullException("LaunchEffect", "LaunchEffect Cannot Be Unassigned on " + this.gameObject.name);
            }
            else Debug.ClearDeveloperConsole();
        }
        catch (System.ArgumentNullException ex)
        {
            Debug.LogException(ex);
        }

        

        MaxSystems = ((Number * Cycles)* Repeat);
        TotalEffects = MaxSystems.ToString("f3") + " Effects";

        if (Fan != null)
        {

            if (Fan.Count != fanSize && Fan.Count != 0)
            {
                Number = Fan.Count;
            }
            fanSize = Fan.Count;
        }

        SetTime();
        SetCycles();
    }


    private bool IsthisPS(GameObject thisss)
    {
        bool temp = false;
        if (thisss.TryGetComponent(out ParticleSystem system)) temp = true;
        return temp;
    }

    public void SetTime()
    {
        float total = 0;
        float totcycle = 0;
        foreach (float j in CycleDelays)
        {
            totcycle += j;
        }
        total += totcycle;
        //Debug.Log(" Time 1 = " + total);
        float temp = TimeDelay;
        for (int i = 0; i < Cycles; i++)
        {
            for (int j = 0; j < Number; j++)
            {
                total += temp;
            }
            temp = temp * Multiplier;
        }
        //Debug.Log(" Time 2 = " + total);
        TotalTime = total;
        updatetime();
    }

    public void SetStartDirections()
    {
        if (CustomDirections == false && Cycles > 0)
        {
            StartDirections.Clear();
            for (int i = 0; i < Cycles; i++)
            {
                if (i % 2 == 0)
                {
                    StartDirections.Add(PlayDirection);
                }
                else
                {
                    StartDirections.Add(!PlayDirection);
                }
            }
        }
    }



    public void SetCycles()
    {
        if (EnableCustomDelays == false)
        {
            CycleDelays.Clear();
            for (int i = 0; i < Cycles; i++)
            {
                CycleDelays.Add(CycleDelay);
            }
        }
    }



    public bool CreateEmpty()
    {
        if (LaunchEffect == ParentObject) return false;
        if (LaunchEffect.gameObject.transform.parent = ParentObject.gameObject.transform) return false;
        GameObject obj = Instantiate(LaunchEffect.gameObject, ParentObject.transform);
        ParticleSystem empty = obj.GetComponent<ParticleSystem>();
        empty.transform.localPosition = new Vector3(0, 0, 0);
        empty.transform.localRotation = new Quaternion(0, 0, 0, 1);
        empty.gameObject.name = "Zipper Start";
        empty.gameObject.SetActive(true);

        for (int i = 0; i < empty.subEmitters.subEmittersCount; i++)
        {
            SafeDestroyGameObject(empty.subEmitters.GetSubEmitterSystem(i));
            empty.subEmitters.RemoveSubEmitter(i);
            i = 0;
        }
        foreach (Transform T in empty.gameObject.transform)
        {
            SafeDestroy(T.gameObject);
        }

        var main = empty.main;
        main.startSize = 0;
        main.maxParticles = MaxParticles;
        main.loop = false;
        float totcycle = 0;
        foreach (float j in CycleDelays)
        {
            totcycle += j;
        }
        if (Number > 0)
        {
            float total = 0;
            total = TimeDelay * (Number*Cycles);
            total += totcycle;
            total = total + LaunchEffect.main.duration;
            main.duration = total;
        }


        ParentObject = empty;
        if (DoesFanExist)
        {
            DeleteFan();
            CreateFan();
        }
        return true;
    }

    public void CreateFan()
    {
        ParentObject.Stop();
        ParentObject.Clear(true);
        ParentObject.Stop(true);
        ParentObject.time = 0;

        if (ParentObject == null)
        {
            if (!CreateEmpty())
            {
                Debug.LogError("EXIT ERROR: This action Requires a Parent Particle System, and one could not be created for you");
                return;
            }
            else Debug.Log("Parent Particle System did not exist, but one was created for you");
        }
        float StartA = Startanlge();
        float StartP = StartPos();
        Debug.Log("Creating Fan with Start Angle of " + StartA);

        for (int i = 0; i < (Number); i++)
        {
            Vector3 Angle = new Vector3(0, 0, StartA);
            Vector3 Position = new Vector3(StartP, 0, 0);
            Debug.Log("Creating Launch Effect at position" + Position.ToString("f3") + " with rotation " + Angle.ToString("f3"));
            Selection.activeGameObject = LaunchEffect.gameObject;
            Unsupported.CopyGameObjectsToPasteboard();
            Unsupported.PasteGameObjectsFromPasteboard();
            var copy = Selection.activeGameObject;
            copy.transform.parent = ParentObject.gameObject.transform;
            //GameObject obj = Instantiate(LaunchEffect.gameObject, ParentObject.gameObject.transform);
            ParticleSystem temp = copy.GetComponent<ParticleSystem>();
            Fan.Add(temp);
            temp.gameObject.transform.localEulerAngles = Angle;
            temp.gameObject.transform.localPosition = Position;
            temp.gameObject.name = "Zipper Effect " + "(" + (i + 1) + ")";
            if (temp.gameObject.activeSelf == false) temp.gameObject.SetActive(true);
            if (OverrideLaunchEffectBurst)
            {
                var emission = temp.emission;
                emission.rateOverTime = 0;
                emission.rateOverDistance = 0;
                emission.burstCount = 0;
            }
            StartA = StartA + LaunchAngles;
            StartP = StartP - PositionSpacing;
        }
        DoesFanExist = true;
        if (Fan.Count > 0)
        {
            ParentObject.Stop(true);
            SetTimings();
        }
        Debug.Log("Zipper Effects Successfuly Created Under Parent Object: " + ParentObject.name);
    }


    public void SetTimings()
    {
        ParentObject.Stop();
        ParentObject.Clear(true);
        ParentObject.Stop(true);
        ParentObject.time = 0;
        SetTime();
        RealTimeDelay = TimeDelay;
        if (ParentObject.isPlaying)
        {
            Debug.LogWarning("Cannot Update Bust While Effect Is Playing!!!");
            return;
        }
        if (CustomDirections == false)
        {
            SetStartDirections();
        }
        var main2 = ParentObject.main;
        main2.duration = (TotalTime + StartDelay) * Repeat;
        main2.loop = false;
        foreach (ParticleSystem P in Fan)
        {
            var main = P.main;
            main.duration = (TotalTime + StartDelay) * Repeat;
            main.maxParticles = MaxParticles;
        }
        if (OverrideLaunchEffectBurst)
        {
            burst.count = 1;
            burst.cycleCount = Repeat;
            burst.probability = 1;
            burst.repeatInterval = TotalTime;
            burst.time = 0;
            CurrTime = StartDelay;
            foreach (ParticleSystem system in Fan)
            {
                var emission = system.emission;
                emission.burstCount = 0;
                emission.rateOverTime = 0;
                emission.rateOverDistance = 0;
            }
            for (int i = 0; i <= (Cycles - 1); i++)
            {
                SetFan(StartDirections[i], i);
                CurrTime = CurrTime + CycleDelays[i];
                RealTimeDelay = RealTimeDelay * Multiplier;
            }
        }
    }

    public void SetFan(bool left, int numb)
    {
        if (left == true)
        {
            for (int V = 0; V <= Fan.Count - 1; V++)
            {
                var emission = Fan[V].emission;
                emission.burstCount = numb+1;
                burst.time = CurrTime + RealTimeDelay;
                emission.SetBurst(numb, burst);
                CurrTime = CurrTime + RealTimeDelay;
            }
        }
        if (left == false)
        {
            for (int V = Fan.Count -1; V >= 0; V--)
            {
                var emission = Fan[V].emission;
                emission.burstCount = numb+1;
                burst.time = CurrTime + RealTimeDelay;
                emission.SetBurst(numb, burst);
                CurrTime = CurrTime + RealTimeDelay;
            }
        }
    }

    public void DeleteFan()
    {
        DoesFanExist = false;
        Debug.Log("Deleted Zipper");
        foreach (ParticleSystem temp in Fan)
        {
            SafeDestroyGameObject(temp);
        }
        Fan.Clear();
        
    }

    public float Startanlge()
    {
        float Angle;
        if (Number % 2 == 0f)
        {
            Angle = (Number / 2f) * LaunchAngles;
        }
        else
        {
            Angle = ((Number / 2f) - 0.5f) * LaunchAngles;
        }
        Angle = Angle * -1.0f;
        return Angle;
    }

    public float StartPos()
    {
        float Angle;
        if (Number % 2 == 0f)
        {
            Angle = (Number / 2f) * PositionSpacing;
        }
        else
        {
            Angle = ((Number / 2f) - 0.5f) * PositionSpacing;
        }
        return Angle;
    }




    public static T SafeDestroy<T>(T obj) where T : Object
    {
        if (Application.isEditor)
            DestroyImmediate(obj);
        else
            Destroy(obj);

        return null;
    }

    public static T SafeDestroyGameObject<T>(T component) where T : Component
    {
        if (component != null)
            SafeDestroy(component.gameObject);
        return null;
    }



 
    #endregion Editor Code



    #region CustomInspector
#if UNITY_EDITOR
    [CustomEditor(typeof(ZipperScript))]
    public class CustomZipperInspector : Editor
    {
        SerializedProperty thisscript;
        private void OnEnable()
        {
            thisscript = serializedObject.FindProperty("thisscript");
        }
        public override void OnInspectorGUI()
        {
            ZipperScript script = (ZipperScript)target;

            base.OnInspectorGUI();
            serializedObject.Update();
            var oldColor = GUI.backgroundColor;
            if (!Application.isPlaying)
            {

                if (script.AdvancedSettings == true)
                {
                    var bool1 = serializedObject.FindProperty("EnableCustomDelays");
                    EditorGUILayout.PropertyField(bool1);
                    if (script.EnableCustomDelays == true)
                    {
                        var list = serializedObject.FindProperty("CycleDelays");
                        EditorGUILayout.PropertyField(list);
                    }
                   
                    var bool2 = serializedObject.FindProperty("CustomDirections");
                    EditorGUILayout.PropertyField(bool2);
                    if (script.CustomDirections == true)
                    {
                        var string1 = serializedObject.FindProperty("Key");
                        EditorGUILayout.PropertyField(string1);
                        var list2 = serializedObject.FindProperty("StartDirections");
                        EditorGUILayout.PropertyField(list2);
                    }
                }
                GUILayout.Space(20);
                if (!script.ParentObject)
                {
                    if (GUILayout.Button("Create Empty Parent Particle System"))
                    {
                        script.CreateEmpty();
                    }
                }
                GUILayout.Space(20);

                GUILayout.Space(20);
                if (script.Fan != null)
                {
                    if (script.Fan.Count > 0)
                    {
                        if (GUILayout.Button("Update Burst Settings"))
                        {
                            script.SetTimings();
                            Debug.Log("Updated burst settings and timings");
                        }
                    }
                }
                GUILayout.Space(20);

                GUILayout.BeginHorizontal("box");
                GUILayout.Space(20);
                GUI.backgroundColor = Color.green;
                if (GUILayout.Button("Create Zipper"))
                {
                    if (script.DoesFanExist == true)
                    {
                        script.ParentObject.Stop(true);
                        script.ParentObject.Clear(true);
                        script.ParentObject.Stop(true);
                        if (script.ParentObject.isPlaying)
                        {
                            Debug.LogError("Cannot Create  particle system When the current one is playing!!");
                        }
                        else
                        {
                            script.DeleteFan();
                            script.CreateFan();
                        }
                    }
                    else script.CreateFan();
                }
                GUI.backgroundColor = oldColor;

                GUILayout.Space(40);
                GUI.backgroundColor = Color.red;
                if (GUILayout.Button("Delete Zipper"))
                {
                    script.DeleteFan();
                }
                GUI.backgroundColor = oldColor;
                GUILayout.Space(20);
                GUILayout.EndHorizontal();
                GUILayout.Space(10);
                GUILayout.Toggle(script.OverrideLaunchEffectBurst, "Override Emmissions on Launch Effect when Created", GUILayout.MaxWidth(500f));
                GUILayout.Space(20);
            }
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
    #endregion CustomInspector



    #region ReadOnlyPoperty
#if UNITY_EDITOR
    public class ReadOnlyAttribute : PropertyAttribute
    {

    }
    [CustomPropertyDrawer(typeof(ReadOnlyAttribute))]
    public class ReadOnlyDrawer : PropertyDrawer
    {
        public override float GetPropertyHeight(SerializedProperty property,
                                                GUIContent label)
        {
            return EditorGUI.GetPropertyHeight(property, label, true);
        }

        public override void OnGUI(Rect position,
                                   SerializedProperty property,
                                   GUIContent label)
        {
            GUI.enabled = false;
            EditorGUI.PropertyField(position, property, label, true);
            GUI.enabled = true;
        }
    }
#endif
    #endregion ReadOnlyProperty

#endif
}

